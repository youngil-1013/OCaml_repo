The root of the proof tree looks like:
G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

We can apply one rule, which is FUN:
   (x: int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

Then, we can apply FUN once more, which yields:
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

Now we apply ADD:
   (y : int), (x : int), G |- 2 * x               (y : int), (x : int), G |- y : int
ADD---------------------------------------------------------------------------------
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

Let us look at the left branch and apply MULT to get:
   (y : int), (x : int), G |- 2 : int                   (y : int), (x : int), G |- x : int
MUL--------------------------------------------------------------------------------------- 
   (y : int), (x : int), G |- 2 * x : int                                                                (y : int), (x : int), G |- y : int     
ADD----------------------------------------------------------------------------------------------------------------------------------------
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

Then, as the left branch of the left branch only has one typing rule we can apply, INT:
INT----------------------------------  
   (y : int), (x : int), G |- 2 : int                   (y : int), (x : int), G |- x : int
MUL--------------------------------------------------------------------------------------- 
   (y : int), (x : int), G |- 2 * x : int                                                                (y : int), (x : int), G |- y : int     
ADD----------------------------------------------------------------------------------------------------------------------------------------
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

We can apply LOOKUP_NOT_FOUND_YET to the right branch of the left branch, which yields:                                          
                                                        (x : int), G |- x : int
INT----------------------------------   LOOKUP_NOT_FOUND----------------------------------
   (y : int), (x : int), G |- 2 : int                   (y : int), (x : int), G |- x : int
MUL---------------------------------------------------------------------------------------  
   (y : int), (x : int), G |- 2 * x : int                                                                (y : int), (x : int), G |- y : int     
ADD----------------------------------------------------------------------------------------------------------------------------------------
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

And now apply LOOKUP_FOUND to the same branch:
                                            LOOKUP_FOUND----------------------
                                                        (x : int), G |- x : int
INT----------------------------------   LOOKUP_NOT_FOUND----------------------------------
   (y : int), (x : int), G |- 2 : int                   (y : int), (x : int), G |- x : int
MUL--------------------------------------------------------------------------------------- 
   (y : int), (x : int), G |- 2 * x : int                                                                (y : int), (x : int), G |- y : int     
ADD----------------------------------------------------------------------------------------------------------------------------------------
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
G |- fun x -> fun y -> (2 * x) + y : int -> int -> int

For the right branch, we can apply LOOKUP_FOUND and the tree is complete:
                                            LOOKUP_FOUND----------------------
                                                        (x : int), G |- x : int
INT----------------------------------   LOOKUP_NOT_FOUND----------------------------------
   (y : int), (x : int), G |- 2 : int                   (y : int), (x : int), G |- x : int
MUL---------------------------------------------------------------------------------------  LOOKUP_FOUND ----------------------------------
   (y : int), (x : int), G |- 2 * x : int                                                                (y : int), (x : int), G |- y : int     
ADD----------------------------------------------------------------------------------------------------------------------------------------
   (y : int), (x : int), G |- (2 * x) + y : int
FUN-------------------------------------------------
   (x : int), G |- fun y -> (2 * x) + y : int -> int
FUN------------------------------------------------------
   G |- fun x -> fun y -> (2 * x) + y : int -> int -> int
